#include "map.h"
#include "unit.h"
#include "globals.h"

#include <iostream>

/* class Map
This class contains information about the tiles on the map.
*/

Map::Map() {}

Map::Map(int rows, int columns) : 
	_rows(rows),
	_columns(columns)
{
	//Create tiles
	int tilesAmount = rows * columns;
	Tile** tiles = new Tile*[tilesAmount];

	for (int id = 0; id < tilesAmount; id++) {
		tiles[id] = new Tile(id, Tile::TerrainAvailability::ALL, this);
	}

	this->_tiles = tiles;

	//Set neighbours to each tile
	for (int id = 0; id < tilesAmount; id++) {
		this->setNeighbours(id, tiles);
	}
	
}

Map::~Map() {
	//Delete Units in _units
	for (int i = 0; i < this->_units.size(); i++) {
		delete this->_units[i];
	}

	//TODO: delete Building in _buildings

	//Delete contents of array _tiles and the array itself
	int tilesAmount = _rows * _columns;
	for (int i = 0; i < tilesAmount; i++) {
		delete this->_tiles[i];
	}
	delete[] this->_tiles;
}

void Map::loadTestMap() {
	/* Legend 
	# = ALL
	y = AIR
	x = NONE
	*/

	std::vector<std::string> mapVector;
	/*
	mapVector = { 
		"##y###",
		"######",
		"######",
		"######",
		"###x##",
	};
	*/
	/* 10 x 8
	mapVector = {
		"#yyy####",
		"###y####",
		"###yxxxx",
		"###yx###",
		"#yxyx###",
		"####x###",
		"####x###",
		"####x###",
		"####x###",
		"######yy",
	};
	*/
	/*
	mapVector = {
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"xxxxxxxxxx######xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx#####xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx#xxxxxxxxx",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"xxxxx#####xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx#####xxxxxxxxxxxxxxxxxxxxxxxxx",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx##xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx#####xxxxxxxx",
		"###x################################################################################################",
		"###x################################################################################################",
		"###x################################################################################################",
		"xxxx################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################",
		"####################################################################################################"
	};
	*/

	mapVector = {
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx#xxxxxxx",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"x#xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx#",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"##################################################",
		"###############################################xxx",
		"###############################################x#x",
		"###############################################xxx",
	};

	for (int id = 0; id < (_rows * _columns); id++) {
		if (mapVector[idToRow(id)][idToColumn(id)] == '#') {
			this->_tiles[id]->setTerrainType(Tile::TerrainAvailability::ALL);
		}
		else if (mapVector[idToRow(id)][idToColumn(id)] == 'y') {
			//cout << "Setting air tile to row " << idToRow(id) << " and column " << idToColumn(id) << endl;
			this->_tiles[id]->setTerrainType(Tile::TerrainAvailability::AIR);
		}
		else if (mapVector[idToRow(id)][idToColumn(id)] == 'x') {
			this->_tiles[id]->setTerrainType(Tile::TerrainAvailability::NONE);
		}
		else {
			std::cout << "Error in creating a map" << std::endl;
		}
	}

	/*
	std::cout << "Position of [0][0] is " << this->_terrain[0][0] << endl;
	std::cout << "Position of [0][2] is " << this->_terrain[0][2] << endl;
	std::cout << "Position of [4][3] is " << this->_terrain[4][3] << endl;
	*/
	
}

void Map::loadTestUnit(int row, int column) {
	Tile* tile = _tiles[positionToId(row, column)];
	Unit* unit = new Unit(tile, Unit::Type::LAND);
	tile->setOccupancy(Tile::Occupancy::LAND);
	_units.push_back(unit);
}

int Map::idToRow(int id) {
	return (id / this->_columns);
}

int Map::idToColumn(int id) {
	return (id % this->_columns);
}

int Map::positionToId(int row, int column) {
	return (column + (row * this->_columns));
}

void Map::update() {
	//UNITS
	/* Whenever I'm moving a unit, I need to change the occupancy of both the tile it left, and the tile it's now on.
	If a stationary unit gets a command to move, it first changes its wantsToMove variable to true.
	Then it check the next tile on the path. If the unit can move there, its variable moving is set to true.
	Once it gets to the target location, wantsToMove and moving get set to false.
	If it encounters a moving obstacle and needs to stop because of that, moving is set to false but
	wantsToMove still remains true.
	*/

	/* If this gets too inefficient, I can make it so that I only check every 5th frame or something like this.
	*/
	for (int i = 0; i < _units.size(); i++) {
		Unit* unit = _units[i];

		/* If the unit wants to move and isn't moving yet, set moving to true (if it's possible) and 
		calculate the distance it needs to travel (diagonal distance is longer).
		*/
		if (unit->getWantsToMove() && !unit->getMoving()) {

			//Check whether the next tile is occupied by a unit of the same type
			Unit::Type unitType = unit->getType();
			Tile::Occupancy occupancy = unit->getPathP()->top()->getOccupancy();
			if ((unitType == Unit::Type::LAND && occupancy == Tile::Occupancy::LAND) ||
					(unitType == Unit::Type::LAND && occupancy == Tile::Occupancy::LAND_AND_AIR) ||
					(unitType == Unit::Type::AIR && occupancy == Tile::Occupancy::AIR) ||
					(unitType == Unit::Type::AIR && occupancy == Tile::Occupancy::LAND_AND_AIR)) {

				//Desired tile is occupied, unit cannot move.
				unit->setMoving(false);
			}
			else {
				//Desired tile isn't occupied, unit can move.
				unit->setMoving(true);

				//Set distance
				int distance = unit->getCurrentTileP->isNeighbourDiagonal(unit->getPathP()->top()) ?
					globals::TILE_DIAGONAL_DISTANCE : globals::TILE_STRAIGHT_DISTANCE;
				unit->setDistance(distance);

			}
		}

		/* If the unit is moving, increment its internal clock (currentDistance) - how close it is to reaching the
		total distance. Once it reaches the total distance, it is now fully on the new tile andcan move to another one.
		*/
		//TODO: Continue here
	}
}

int Map::getRows() {
	return this->_rows;
}

int Map::getColumns() {
	return this->_columns;
}

std::vector<Unit*>* Map::getUnitsP() {
	return &this->_units;
}

Tile** Map::getTilesP() {
	return this->_tiles;
}

//PRIVATE METHODS
void Map::setNeighbours(int id, Tile** tiles) {
	std::vector<Tile*> neighbours;
	int row = idToRow(id);
	int column = idToColumn(id);

	//Loop through all tiles around the current tile
	for (int r = -1; r <= 1; r++) {	
		for (int c = -1; c <= 1; c++) {

			//Skip iterating through itself
			if (r == 0 && c == 0) {
				continue;
			}

			//If the tile is at the edge, skip tiles that would be out of bounds
			if ((row == 0 && r == -1) || 
				(row == (this->_rows - 1) && r == 1) || 
				(column == 0 && c == -1) || 
				(column == (this->_columns - 1) && c == 1)) {
				continue;
			}

			//Add this tile to the neighbours vector
			neighbours.push_back(tiles[positionToId(row + r, column + c)]);
		}
	}

	//Add the vector to the current tile
	tiles[id]->setNeighbours(neighbours);
}